{"ast":null,"code":"import { encodePacket, encodePacketToBinary } from \"./encodePacket.js\";\nimport { decodePacket } from \"./decodePacket.js\";\nimport { ERROR_PACKET } from \"./commons.js\";\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\n\nconst encodePayload = (packets, callback) => {\n  // some packets may be added to the array while encoding, so the initial length must be saved\n  const length = packets.length;\n  const encodedPackets = new Array(length);\n  let count = 0;\n  packets.forEach((packet, i) => {\n    // force base64 encoding for binary packets\n    encodePacket(packet, false, encodedPacket => {\n      encodedPackets[i] = encodedPacket;\n\n      if (++count === length) {\n        callback(encodedPackets.join(SEPARATOR));\n      }\n    });\n  });\n};\n\nconst decodePayload = (encodedPayload, binaryType) => {\n  const encodedPackets = encodedPayload.split(SEPARATOR);\n  const packets = [];\n\n  for (let i = 0; i < encodedPackets.length; i++) {\n    const decodedPacket = decodePacket(encodedPackets[i], binaryType);\n    packets.push(decodedPacket);\n\n    if (decodedPacket.type === \"error\") {\n      break;\n    }\n  }\n\n  return packets;\n};\n\nexport function createPacketEncoderStream() {\n  // @ts-expect-error\n  return new TransformStream({\n    transform(packet, controller) {\n      encodePacketToBinary(packet, encodedPacket => {\n        const payloadLength = encodedPacket.length;\n        let header; // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length\n\n        if (payloadLength < 126) {\n          header = new Uint8Array(1);\n          new DataView(header.buffer).setUint8(0, payloadLength);\n        } else if (payloadLength < 65536) {\n          header = new Uint8Array(3);\n          const view = new DataView(header.buffer);\n          view.setUint8(0, 126);\n          view.setUint16(1, payloadLength);\n        } else {\n          header = new Uint8Array(9);\n          const view = new DataView(header.buffer);\n          view.setUint8(0, 127);\n          view.setBigUint64(1, BigInt(payloadLength));\n        } // first bit indicates whether the payload is plain text (0) or binary (1)\n\n\n        if (packet.data && typeof packet.data !== \"string\") {\n          header[0] |= 0x80;\n        }\n\n        controller.enqueue(header);\n        controller.enqueue(encodedPacket);\n      });\n    }\n\n  });\n}\nlet TEXT_DECODER;\n\nfunction totalLength(chunks) {\n  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);\n}\n\nfunction concatChunks(chunks, size) {\n  if (chunks[0].length === size) {\n    return chunks.shift();\n  }\n\n  const buffer = new Uint8Array(size);\n  let j = 0;\n\n  for (let i = 0; i < size; i++) {\n    buffer[i] = chunks[0][j++];\n\n    if (j === chunks[0].length) {\n      chunks.shift();\n      j = 0;\n    }\n  }\n\n  if (chunks.length && j < chunks[0].length) {\n    chunks[0] = chunks[0].slice(j);\n  }\n\n  return buffer;\n}\n\nexport function createPacketDecoderStream(maxPayload, binaryType) {\n  if (!TEXT_DECODER) {\n    TEXT_DECODER = new TextDecoder();\n  }\n\n  const chunks = [];\n  let state = 0\n  /* READ_HEADER */\n  ;\n  let expectedLength = -1;\n  let isBinary = false; // @ts-expect-error\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      chunks.push(chunk);\n\n      while (true) {\n        if (state === 0\n        /* READ_HEADER */\n        ) {\n            if (totalLength(chunks) < 1) {\n              break;\n            }\n\n            const header = concatChunks(chunks, 1);\n            isBinary = (header[0] & 0x80) === 0x80;\n            expectedLength = header[0] & 0x7f;\n\n            if (expectedLength < 126) {\n              state = 3\n              /* READ_PAYLOAD */\n              ;\n            } else if (expectedLength === 126) {\n              state = 1\n              /* READ_EXTENDED_LENGTH_16 */\n              ;\n            } else {\n              state = 2\n              /* READ_EXTENDED_LENGTH_64 */\n              ;\n            }\n          } else if (state === 1\n        /* READ_EXTENDED_LENGTH_16 */\n        ) {\n            if (totalLength(chunks) < 2) {\n              break;\n            }\n\n            const headerArray = concatChunks(chunks, 2);\n            expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);\n            state = 3\n            /* READ_PAYLOAD */\n            ;\n          } else if (state === 2\n        /* READ_EXTENDED_LENGTH_64 */\n        ) {\n            if (totalLength(chunks) < 8) {\n              break;\n            }\n\n            const headerArray = concatChunks(chunks, 8);\n            const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);\n            const n = view.getUint32(0);\n\n            if (n > Math.pow(2, 53 - 32) - 1) {\n              // the maximum safe integer in JavaScript is 2^53 - 1\n              controller.enqueue(ERROR_PACKET);\n              break;\n            }\n\n            expectedLength = n * Math.pow(2, 32) + view.getUint32(4);\n            state = 3\n            /* READ_PAYLOAD */\n            ;\n          } else {\n          if (totalLength(chunks) < expectedLength) {\n            break;\n          }\n\n          const data = concatChunks(chunks, expectedLength);\n          controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));\n          state = 0\n          /* READ_HEADER */\n          ;\n        }\n\n        if (expectedLength === 0 || expectedLength > maxPayload) {\n          controller.enqueue(ERROR_PACKET);\n          break;\n        }\n      }\n    }\n\n  });\n}\nexport const protocol = 4;\nexport { encodePacket, encodePayload, decodePacket, decodePayload };","map":{"version":3,"sources":["C:/Users/Nathan/Documents/CSULB stuff/cecs327/Networking-class/JS PRACTICE/client/node_modules/engine.io-parser/build/esm/index.js"],"names":["encodePacket","encodePacketToBinary","decodePacket","ERROR_PACKET","SEPARATOR","String","fromCharCode","encodePayload","packets","callback","length","encodedPackets","Array","count","forEach","packet","i","encodedPacket","join","decodePayload","encodedPayload","binaryType","split","decodedPacket","push","type","createPacketEncoderStream","TransformStream","transform","controller","payloadLength","header","Uint8Array","DataView","buffer","setUint8","view","setUint16","setBigUint64","BigInt","data","enqueue","TEXT_DECODER","totalLength","chunks","reduce","acc","chunk","concatChunks","size","shift","j","slice","createPacketDecoderStream","maxPayload","TextDecoder","state","expectedLength","isBinary","headerArray","byteOffset","getUint16","n","getUint32","Math","pow","decode","protocol"],"mappings":"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","sourcesContent":["import { encodePacket, encodePacketToBinary } from \"./encodePacket.js\";\r\nimport { decodePacket } from \"./decodePacket.js\";\r\nimport { ERROR_PACKET, } from \"./commons.js\";\r\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\r\nconst encodePayload = (packets, callback) => {\r\n    // some packets may be added to the array while encoding, so the initial length must be saved\r\n    const length = packets.length;\r\n    const encodedPackets = new Array(length);\r\n    let count = 0;\r\n    packets.forEach((packet, i) => {\r\n        // force base64 encoding for binary packets\r\n        encodePacket(packet, false, (encodedPacket) => {\r\n            encodedPackets[i] = encodedPacket;\r\n            if (++count === length) {\r\n                callback(encodedPackets.join(SEPARATOR));\r\n            }\r\n        });\r\n    });\r\n};\r\nconst decodePayload = (encodedPayload, binaryType) => {\r\n    const encodedPackets = encodedPayload.split(SEPARATOR);\r\n    const packets = [];\r\n    for (let i = 0; i < encodedPackets.length; i++) {\r\n        const decodedPacket = decodePacket(encodedPackets[i], binaryType);\r\n        packets.push(decodedPacket);\r\n        if (decodedPacket.type === \"error\") {\r\n            break;\r\n        }\r\n    }\r\n    return packets;\r\n};\r\nexport function createPacketEncoderStream() {\r\n    // @ts-expect-error\r\n    return new TransformStream({\r\n        transform(packet, controller) {\r\n            encodePacketToBinary(packet, (encodedPacket) => {\r\n                const payloadLength = encodedPacket.length;\r\n                let header;\r\n                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length\r\n                if (payloadLength < 126) {\r\n                    header = new Uint8Array(1);\r\n                    new DataView(header.buffer).setUint8(0, payloadLength);\r\n                }\r\n                else if (payloadLength < 65536) {\r\n                    header = new Uint8Array(3);\r\n                    const view = new DataView(header.buffer);\r\n                    view.setUint8(0, 126);\r\n                    view.setUint16(1, payloadLength);\r\n                }\r\n                else {\r\n                    header = new Uint8Array(9);\r\n                    const view = new DataView(header.buffer);\r\n                    view.setUint8(0, 127);\r\n                    view.setBigUint64(1, BigInt(payloadLength));\r\n                }\r\n                // first bit indicates whether the payload is plain text (0) or binary (1)\r\n                if (packet.data && typeof packet.data !== \"string\") {\r\n                    header[0] |= 0x80;\r\n                }\r\n                controller.enqueue(header);\r\n                controller.enqueue(encodedPacket);\r\n            });\r\n        },\r\n    });\r\n}\r\nlet TEXT_DECODER;\r\nfunction totalLength(chunks) {\r\n    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);\r\n}\r\nfunction concatChunks(chunks, size) {\r\n    if (chunks[0].length === size) {\r\n        return chunks.shift();\r\n    }\r\n    const buffer = new Uint8Array(size);\r\n    let j = 0;\r\n    for (let i = 0; i < size; i++) {\r\n        buffer[i] = chunks[0][j++];\r\n        if (j === chunks[0].length) {\r\n            chunks.shift();\r\n            j = 0;\r\n        }\r\n    }\r\n    if (chunks.length && j < chunks[0].length) {\r\n        chunks[0] = chunks[0].slice(j);\r\n    }\r\n    return buffer;\r\n}\r\nexport function createPacketDecoderStream(maxPayload, binaryType) {\r\n    if (!TEXT_DECODER) {\r\n        TEXT_DECODER = new TextDecoder();\r\n    }\r\n    const chunks = [];\r\n    let state = 0 /* READ_HEADER */;\r\n    let expectedLength = -1;\r\n    let isBinary = false;\r\n    // @ts-expect-error\r\n    return new TransformStream({\r\n        transform(chunk, controller) {\r\n            chunks.push(chunk);\r\n            while (true) {\r\n                if (state === 0 /* READ_HEADER */) {\r\n                    if (totalLength(chunks) < 1) {\r\n                        break;\r\n                    }\r\n                    const header = concatChunks(chunks, 1);\r\n                    isBinary = (header[0] & 0x80) === 0x80;\r\n                    expectedLength = header[0] & 0x7f;\r\n                    if (expectedLength < 126) {\r\n                        state = 3 /* READ_PAYLOAD */;\r\n                    }\r\n                    else if (expectedLength === 126) {\r\n                        state = 1 /* READ_EXTENDED_LENGTH_16 */;\r\n                    }\r\n                    else {\r\n                        state = 2 /* READ_EXTENDED_LENGTH_64 */;\r\n                    }\r\n                }\r\n                else if (state === 1 /* READ_EXTENDED_LENGTH_16 */) {\r\n                    if (totalLength(chunks) < 2) {\r\n                        break;\r\n                    }\r\n                    const headerArray = concatChunks(chunks, 2);\r\n                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);\r\n                    state = 3 /* READ_PAYLOAD */;\r\n                }\r\n                else if (state === 2 /* READ_EXTENDED_LENGTH_64 */) {\r\n                    if (totalLength(chunks) < 8) {\r\n                        break;\r\n                    }\r\n                    const headerArray = concatChunks(chunks, 8);\r\n                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);\r\n                    const n = view.getUint32(0);\r\n                    if (n > Math.pow(2, 53 - 32) - 1) {\r\n                        // the maximum safe integer in JavaScript is 2^53 - 1\r\n                        controller.enqueue(ERROR_PACKET);\r\n                        break;\r\n                    }\r\n                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);\r\n                    state = 3 /* READ_PAYLOAD */;\r\n                }\r\n                else {\r\n                    if (totalLength(chunks) < expectedLength) {\r\n                        break;\r\n                    }\r\n                    const data = concatChunks(chunks, expectedLength);\r\n                    controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));\r\n                    state = 0 /* READ_HEADER */;\r\n                }\r\n                if (expectedLength === 0 || expectedLength > maxPayload) {\r\n                    controller.enqueue(ERROR_PACKET);\r\n                    break;\r\n                }\r\n            }\r\n        },\r\n    });\r\n}\r\nexport const protocol = 4;\r\nexport { encodePacket, encodePayload, decodePacket, decodePayload, };\r\n"]},"metadata":{},"sourceType":"module"}